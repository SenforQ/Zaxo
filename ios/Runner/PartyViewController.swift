
//: Declare String Begin

/*: "document.getElementsByTagName('body')[0].style.background='rgba(0,0,0,0)'" :*/
fileprivate let serviceGenerateUrl:[UInt8] = [0x4d,0x46,0x4a,0x5c,0x44,0x4c,0x47,0x5d,0x7,0x4e,0x4c,0x5d,0x6c,0x45,0x4c,0x44,0x4c,0x47,0x5d,0x5a,0x6b,0x50,0x7d,0x48,0x4e,0x67,0x48,0x44,0x4c,0x1,0xe,0x4b,0x46,0x4d,0x50,0xe,0x0,0x72,0x19,0x74,0x7,0x5a,0x5d,0x50,0x45,0x4c,0x7,0x4b,0x48,0x4a,0x42,0x4e,0x5b,0x46,0x5c,0x47,0x4d,0x14,0xe,0x5b,0x4e,0x4b,0x48,0x1,0x19,0x5,0x19,0x5,0x19,0x5,0x19,0x0,0xe]

private func dayScheme(tap num: UInt8) -> UInt8 {
    return num ^ 41
}

/*: "closeWeb" :*/
fileprivate let constMirrorName:String = "cbackgroundose"
fileprivate let showIndexReportName:String = "access whiteWeb"

/*: "toUrl" :*/
fileprivate let viewMainCount:String = "save maketoUrl"

/*: "syncAppInfo" :*/
fileprivate let sessionSoundMessage:String = "SYNC"

/*: "typeName" :*/
fileprivate let notiCarrierName:[Character] = ["t","y","p","e","N","a"]
fileprivate let factoryFrameState:String = "mremote"

/*: "isAuth" :*/
fileprivate let dataModelValue:String = "isAuthwhere flexible challenge engine frame"

/*: "isFirst" :*/
fileprivate let factoryBounceError:[Character] = ["i","s","F","i","r","s","t"]

/*: "Please click 'Go' to allow access" :*/
fileprivate let loggerMakeStr:[UInt8] = [0x82,0xbe,0xb7,0xb3,0xa1,0xb7,0xf2,0xb1,0xbe,0xbb,0xb1,0xb9,0xf2,0xf5,0x95,0xbd,0xf5,0xf2,0xa6,0xbd,0xf2,0xb3,0xbe,0xbe,0xbd,0xa5,0xf2,0xb3,0xb1,0xb1,0xb7,0xa1,0xa1]

private func deviceInfo(sum num: UInt8) -> UInt8 {
    return num ^ 210
}

/*: "getCameraStatus" :*/
fileprivate let viewInsideKey:[Character] = ["g","e","t","C","a","m","e","r","a","S"]
fileprivate let user_scaleTransactionDate:String = "willawillus"

/*: "Please allow ' :*/
fileprivate let modelActiveAgentDict:String = "display head text handlePlea"
fileprivate let notiSDict:String = "low error local item"
fileprivate let k_neverLevelValue:[Character] = ["\'"]

/*: ' to access your camera in your iPhone's 'Settings-Privacy-Camera' option" :*/
fileprivate let show_souvenirId:[UInt8] = [0x71,0x76,0x22,0x39,0x76,0x37,0x35,0x35,0x33,0x25,0x25,0x76,0x2f,0x39,0x23,0x24,0x76,0x35,0x37,0x3b,0x33,0x24,0x37,0x76,0x3f,0x38,0x76,0x2f,0x39,0x23,0x24,0x76,0x3f,0x6,0x3e,0x39,0x38,0x33,0x71,0x25,0x76,0x71,0x5,0x33,0x22,0x22,0x3f,0x38,0x31,0x25,0x7b,0x6,0x24,0x3f,0x20,0x37,0x35,0x2f,0x7b,0x15,0x37,0x3b,0x33,0x24,0x37,0x71,0x76,0x39,0x26,0x22,0x3f,0x39,0x38]

private func sharedCancel(m num: UInt8) -> UInt8 {
    return num ^ 86
}

/*: "getPhotoStatus" :*/
fileprivate let mainRePrivacyDict:String = "getPvalue post disappear trust base"
fileprivate let serviceStatusResult:String = "Statusbelow will disappear"

/*: ' to access your album in your iPhone's 'Settings-Privacy-Album' option" :*/
fileprivate let userPareMessage:[UInt8] = [0x51,0x56,0x2,0x19,0x56,0x17,0x15,0x15,0x13,0x5,0x5,0x56,0xf,0x19,0x3,0x4,0x56,0x17,0x1a,0x14,0x3,0x1b,0x56,0x1f,0x18,0x56,0xf,0x19,0x3,0x4,0x56,0x1f,0x26,0x1e,0x19,0x18,0x13,0x51,0x5,0x56,0x51,0x25,0x13,0x2,0x2,0x1f,0x18,0x11,0x5,0x5b,0x26,0x4,0x1f,0x0,0x17,0x15,0xf,0x5b,0x37,0x1a,0x14,0x3,0x1b,0x51,0x56,0x19,0x6,0x2,0x1f,0x19,0x18]

/*: "getMicStatus" :*/
fileprivate let appPanelFlag:String = "getMicenter promise user select"
fileprivate let app_receiveEngineStr:String = "tdismiss"

/*: ' to access your microphone in your iPhone's 'Settings-Privacy-Microphone' option" :*/
fileprivate let factoryMessageStatus:[UInt8] = [0xf7,0xf0,0x44,0x3f,0xf0,0x31,0x33,0x33,0x35,0x43,0x43,0xf0,0x49,0x3f,0x45,0x42,0xf0,0x3d,0x39,0x33,0x42,0x3f,0x40,0x38,0x3f,0x3e,0x35,0xf0,0x39,0x3e,0xf0,0x49,0x3f,0x45,0x42,0xf0,0x39,0x20,0x38,0x3f,0x3e,0x35,0xf7,0x43,0xf0,0xf7,0x23,0x35,0x44,0x44,0x39,0x3e,0x37,0x43,0xfd,0x20,0x42,0x39,0x46,0x31,0x33,0x49,0xfd,0x1d,0x39,0x33,0x42,0x3f,0x40,0x38,0x3f,0x3e,0x35,0xf7,0xf0,0x3f,0x40,0x44,0x39,0x3f,0x3e]

fileprivate func cutReduceName(hour num: UInt8) -> UInt8 {
    let value = Int(num) + 48
    if value > 255 {
        return UInt8(value - 256)
    } else {
        return UInt8(value)
    }
}

/*: "Cancel" :*/
fileprivate let appSumryPath:[Character] = ["C","a","n","c","e"]
fileprivate let engineMainString:[Character] = ["l"]

/*: "Poor network, loading failed" :*/
fileprivate let showReKey:String = "event process any displayPoor n"
fileprivate let engineActivityList:String = "area bridge log tork, l"
fileprivate let noti_conceptAlbumKey:String = "screen info result fai"
fileprivate let managerPageTempState:String = "lecancel"

/*: "Refresh" :*/
fileprivate let networkCountlessnessFlag:[Character] = ["R","e","f","r","e"]
fileprivate let scaleTabMessage:String = "makeup"

/*: "Alert" :*/
fileprivate let const_policyMode:String = "script transform secondAlert"

/*: "Done" :*/
fileprivate let routerKitError:String = "Doneblack till"

/*: "HttpTool.NativeToJs('recharge')" :*/
fileprivate let data_previousSoundLargeMsg:[UInt8] = [0x6c,0x50,0x50,0x54,0x70,0x4b,0x4b,0x48,0xa,0x6a,0x45,0x50,0x4d,0x52,0x41,0x70,0x4b,0x6e,0x57,0xc,0x3,0x56,0x41,0x47,0x4c,0x45,0x56,0x43,0x41,0x3,0xd]

private func generateListBehavior(white num: UInt8) -> UInt8 {
    return num ^ 36
}

/*: "onPageShow" :*/
fileprivate let const_photoDict:String = "instance textonP"
fileprivate let main_kitSpaceValue:[Character] = ["a","g","e","S","h","o","w"]

/*: "window.onPageShow&&onPageShow();" :*/
fileprivate let networkPermissionPath:[UInt8] = [0x8d,0x93,0x94,0x9e,0x95,0x8d,0xd4,0x95,0x94,0xaa,0x9b,0x9d,0x9f,0xa9,0x92,0x95,0x8d,0xdc,0xdc,0x95,0x94,0xaa,0x9b,0x9d,0x9f,0xa9,0x92,0x95,0x8d,0xd2,0xd3,0xc1]

private func fitLaunch(flexible num: UInt8) -> UInt8 {
    return num ^ 250
}

/*: "onPageHide" :*/
fileprivate let constQuestionMode:String = "onPaself background current link"
fileprivate let modelServerStatus:String = "need"

/*: "window.onPageHide&&onPageHide();" :*/
fileprivate let dataSwapFormat:[UInt8] = [0xc6,0xd8,0xdf,0xd5,0xde,0xc6,0x9f,0xde,0xdf,0xe1,0xd0,0xd6,0xd4,0xf9,0xd8,0xd5,0xd4,0x97,0x97,0xde,0xdf,0xe1,0xd0,0xd6,0xd4,0xf9,0xd8,0xd5,0xd4,0x99,0x98,0x8a]

private func postValid(product num: UInt8) -> UInt8 {
    return num ^ 177
}

//: Declare String End

// __DEBUG__
// __CLOSE_PRINT__
//
//  ViewController.swift
//  OverseaH5
//
//  Created by DouXiu on 2025/9/23.
//

//: import UIKit
import UIKit
//: import WebViewJavascriptBridge
import WebViewJavascriptBridge
//: import WebKit
import WebKit

//: class AppWebViewController: UIViewController {
class PartyViewController: UIViewController {
    
    //: var urlString: String = ""
    var urlString: String = ""
    /// 是否背景透明
    //: var clearBgColor = false
    var clearBgColor = false
    /// 是否全屏
    //: var fullscreen = true
    var fullscreen = true
    
    //: private var bridge: WebViewJavascriptBridge?
    private var bridge: WebViewJavascriptBridge?
    
    // Pending JS dialog completion handlers (ensure always-called to avoid WKWebView crash)
    //: private var pendingAlertCompletion: (() -> Void)?
    private var pendingAlertCompletion: (() -> Void)?
    //: private var pendingConfirmCompletion: ((Bool) -> Void)?
    private var pendingConfirmCompletion: ((Bool) -> Void)?
    //: private var pendingPromptCompletion: ((String?) -> Void)?
    private var pendingPromptCompletion: ((String?) -> Void)?

    //: lazy var webView: WKWebView = {
    lazy var webView: WKWebView = {
        //: let webConfig = WKWebViewConfiguration()
        let webConfig = WKWebViewConfiguration()
        //: let preferences = WKPreferences()
        let preferences = WKPreferences()
        //: preferences.javaScriptEnabled = true
        preferences.javaScriptEnabled = true
        //: webConfig.preferences = preferences
        webConfig.preferences = preferences
        //: webConfig.allowsInlineMediaPlayback = true
        webConfig.allowsInlineMediaPlayback = true
        //: webConfig.mediaTypesRequiringUserActionForPlayback = []
        webConfig.mediaTypesRequiringUserActionForPlayback = []
        //: let userControl = WKUserContentController()
        let userControl = WKUserContentController()
        //: webConfig.userContentController = userControl
        webConfig.userContentController = userControl
        //: let w = WKWebView(frame: .zero, configuration: webConfig)
        let w = WKWebView(frame: .zero, configuration: webConfig)
        //: w.uiDelegate = self
        w.uiDelegate = self
        //: w.navigationDelegate = self
        w.navigationDelegate = self
        //: w.allowsLinkPreview = false
        w.allowsLinkPreview = false
        //: w.allowsBackForwardNavigationGestures = true
        w.allowsBackForwardNavigationGestures = true
        //: w.scrollView.contentInsetAdjustmentBehavior = .never
        w.scrollView.contentInsetAdjustmentBehavior = .never
        //: w.isOpaque = false
        w.isOpaque = false
        //: w.scrollView.bounces = false
        w.scrollView.bounces = false
        //: w.scrollView.alwaysBounceVertical = false
        w.scrollView.alwaysBounceVertical = false
        //: w.scrollView.alwaysBounceHorizontal = false
        w.scrollView.alwaysBounceHorizontal = false
        //: return w
        return w
    //: }()
    }()

    //: override func viewDidLoad() {
    override func viewDidLoad() {
        //: super.viewDidLoad()
        super.viewDidLoad()
        //: view.addSubview(self.webView)
        view.addSubview(self.webView)
        //: var frame = CGRect(origin: CGPoint.zero, size: UIScreen.main.bounds.size)
        var frame = CGRect(origin: CGPoint.zero, size: UIScreen.main.bounds.size)
        //: if fullscreen == false {
        if fullscreen == false {
            //: frame.origin.y = AppConfig.getStatusBarHeight()
            frame.origin.y = IndicatorDisableBegin.deadline()
        }
        //: self.webView.frame = frame
        self.webView.frame = frame
 
        //: self.addBridgeMethod()
        self.explode()
        //: self.beginStartRequest()
        self.fail()
 
        // 应用从后台切换到前台
        //: NotificationCenter.default.addObserver(self,
        NotificationCenter.default.addObserver(self,
                                               //: selector: #selector(jsEvent_onPageShow),
                                               selector: #selector(anyRating),
                                               //: name: UIApplication.willEnterForegroundNotification,
                                               name: UIApplication.willEnterForegroundNotification,
                                               //: object: nil)
                                               object: nil)
    }
    
    //: override func viewWillAppear(_ animated: Bool) {
    override func viewWillAppear(_ animated: Bool) {
        //: super.viewWillAppear(animated)
        super.viewWillAppear(animated)
        //: jsEvent_onPageShow()
        anyRating()
    }
    
    //: override func viewWillDisappear(_ animated: Bool) {
    override func viewWillDisappear(_ animated: Bool) {
        //: super.viewWillDisappear(animated)
        super.viewWillDisappear(animated)
        //: jsEvent_onPageHide()
        post()
        //: finalizePendingJSHandlersIfNeeded()
        appear()
    }

    //: deinit {
    deinit {
        //: removeBridgeMethod()
        pedagogyEvaluate()
        //: finalizePendingJSHandlersIfNeeded()
        appear()
    }

    /// 发起网页请求
    //: private func beginStartRequest() {
    private func fail() {
        //: if let url = URL(string: urlString) {
        if let url = URL(string: urlString) {
            //: let urlRequest = URLRequest(url: url)
            let urlRequest = URLRequest(url: url)
            //: self.webView.load(urlRequest)
            self.webView.load(urlRequest)
            //: self.clearJSBgColor()
            self.inputPrompt()
        }
    }
    
    /// 设置页面为透明
    //: private func clearJSBgColor() {
    private func inputPrompt() {
        //: guard clearBgColor == true else { return }
        guard clearBgColor == true else { return }
        //: webView.evaluateJavaScript("document.getElementsByTagName('body')[0].style.background='rgba(0,0,0,0)'") { _, _  in
        webView.evaluateJavaScript(String(bytes: serviceGenerateUrl.map{dayScheme(tap: $0)}, encoding: .utf8)!) { _, _  in
        }
        //: view.backgroundColor = .clear
        view.backgroundColor = .clear
        //: webView.backgroundColor = .clear
        webView.backgroundColor = .clear
        //: webView.scrollView.backgroundColor = .clear
        webView.scrollView.backgroundColor = .clear
        //: webView.scrollView.bounces = false
        webView.scrollView.bounces = false
        //: webView.scrollView.alwaysBounceVertical = false
        webView.scrollView.alwaysBounceVertical = false
        //: webView.scrollView.alwaysBounceHorizontal = false
        webView.scrollView.alwaysBounceHorizontal = false
        //: webView.isOpaque = false
        webView.isOpaque = false
    }
    
    /// 关闭webview事件
    //: func closeWeb() {
    func head() {
        //: if webView.canGoBack {
        if webView.canGoBack {
            //: webView.goBack()
            webView.goBack()
            //: return
            return
        }
        
        //: removeBridgeMethod()
        pedagogyEvaluate()
        //: if self.presentingViewController != nil {
        if self.presentingViewController != nil {
            // 当前页面dismiss后，下面还是网页时，手动调用viewDidAppear
            //: dismiss(animated: true) {
            dismiss(animated: true) {
                //: if let currentVC = AppConfig.currentViewController() {
                if let currentVC = IndicatorDisableBegin.laissezPasser() {
                    //: if currentVC.isKind(of: AppWebViewController.self) {
                    if currentVC.isKind(of: PartyViewController.self) {
                        //: (currentVC as! AppWebViewController).jsEvent_onPageShow()
                        (currentVC as! PartyViewController).anyRating()
                    }
                }
            }
        }
    }
}

//: extension AppWebViewController: WKScriptMessageHandler, WebViewJavascriptBridgeBaseDelegate {
extension PartyViewController: WKScriptMessageHandler, WebViewJavascriptBridgeBaseDelegate {
    //: func _evaluateJavascript(_ javascriptCommand: String!) -> String! {
    func _evaluateJavascript(_ javascriptCommand: String!) -> String! {
        //: return ""
        return ""
    }

    //: func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        //: print("js call method name = \(message.name), message = \(message.body)")
        // 兼容老事件
        //: DispatchQueue.main.async {
        DispatchQueue.main.async {
            //: let type = message.name
            let type = message.name
            //: if type == "closeWeb" {
            if type == (constMirrorName.replacingOccurrences(of: "background", with: "l") + String(showIndexReportName.suffix(3))) {
                //: self.closeWeb()
                self.head()
                
            //: } else if type == "toUrl" {
            } else if type == (String(viewMainCount.suffix(5))) {
                //: if let url = message.body as? String {
                if let url = message.body as? String {
                    //: AppWebViewController.openNewWebView(url)
                    PartyViewController.writerSName(url)
                }
            }
        }
    }

    //: func addBridgeMethod() {
    func explode() {
        //: self.bridge = WebViewJavascriptBridge(self.webView)
        self.bridge = WebViewJavascriptBridge(self.webView)
        //: self.bridge?.setWebViewDelegate(self)
        self.bridge?.setWebViewDelegate(self)
        //: self.bridge?.registerHandler("syncAppInfo", handler: { data, callback in
        self.bridge?.registerHandler((sessionSoundMessage.lowercased() + "AppInfo"), handler: { data, callback in
            //: print("js call getUserIdFromObjC, data from js is %@", data as Any)
            //: if callback != nil {
            if callback != nil {
                //: if let dic = data as? [String: Any] {
                if let dic = data as? [String: Any] {
                    //: self.handleH5Message(schemeDic: dic) { backDic in
                    self.with(schemeDic: dic) { backDic in
                        //: callback?(backDic)
                        callback?(backDic)
                        //: DispatchQueue.main.async {
                        DispatchQueue.main.async {
                            //: self.handAuthOpenURL(dic: backDic)
                            self.act(dic: backDic)
                        }
                    }
                }
            }
        //: })
        })
        //: let ucController = self.webView.configuration.userContentController
        let ucController = self.webView.configuration.userContentController
        //: ucController.add(AppWebViewScriptDelegateHandler(self), name: "closeWeb")
        ucController.add(PlumeTap(self), name: (constMirrorName.replacingOccurrences(of: "background", with: "l") + String(showIndexReportName.suffix(3))))
        //: ucController.add(AppWebViewScriptDelegateHandler(self), name: "toUrl")
        ucController.add(PlumeTap(self), name: (String(viewMainCount.suffix(5))))
    }

    //: func removeBridgeMethod() {
    func pedagogyEvaluate() {
        //: let ucController = self.webView.configuration.userContentController
        let ucController = self.webView.configuration.userContentController
        //: if #available(iOS 14.0, *) {
        if #available(iOS 14.0, *) {
            //: ucController.removeAllScriptMessageHandlers()
            ucController.removeAllScriptMessageHandlers()
        //: } else {
        } else {
            //: ucController.removeScriptMessageHandler(forName: "closeWeb")
            ucController.removeScriptMessageHandler(forName: (constMirrorName.replacingOccurrences(of: "background", with: "l") + String(showIndexReportName.suffix(3))))
            //: ucController.removeScriptMessageHandler(forName: "toUrl")
            ucController.removeScriptMessageHandler(forName: (String(viewMainCount.suffix(5))))
        }
    }

    //: func handAuthOpenURL(dic: [String: Any]) {
    func act(dic: [String: Any]) {
        //: if let typeName = dic["typeName"] as? String, let isAuth = dic["isAuth"] as? Bool, let isFirst = dic["isFirst"] as? Bool {
        if let typeName = dic[(String(notiCarrierName) + factoryFrameState.replacingOccurrences(of: "remote", with: "e"))] as? String, let isAuth = dic[(String(dataModelValue.prefix(6)))] as? Bool, let isFirst = dic[(String(factoryBounceError))] as? Bool {
            //: if isAuth || isFirst {
            if isAuth || isFirst {
                //: return
                return
            }
            //: var message = "Please click 'Go' to allow access"
            var message = String(bytes: loggerMakeStr.map{deviceInfo(sum: $0)}, encoding: .utf8)!
            //: var needAlert = false
            var needAlert = false
            //: if typeName == "getCameraStatus" {
            if typeName == (String(viewInsideKey) + user_scaleTransactionDate.replacingOccurrences(of: "will", with: "t")) {
                //: needAlert = true
                needAlert = true
                //: message = "Please allow '\(AppName)' to access your camera in your iPhone's 'Settings-Privacy-Camera' option"
                message = (String(modelActiveAgentDict.suffix(4)) + "se al" + String(notiSDict.prefix(4)) + String(k_neverLevelValue)) + "\(noti_areaName)" + String(bytes: show_souvenirId.map{sharedCancel(m: $0)}, encoding: .utf8)!
                
            //: } else if typeName == "getPhotoStatus" {
            } else if typeName == (String(mainRePrivacyDict.prefix(4)) + "hoto" + String(serviceStatusResult.prefix(6))) {
                //: needAlert = true
                needAlert = true
                //: message = "Please allow '\(AppName)' to access your album in your iPhone's 'Settings-Privacy-Album' option"
                message = (String(modelActiveAgentDict.suffix(4)) + "se al" + String(notiSDict.prefix(4)) + String(k_neverLevelValue)) + "\(noti_areaName)" + String(bytes: userPareMessage.map{$0^118}, encoding: .utf8)!
                
            //: } else if typeName == "getMicStatus" {
            } else if typeName == (String(appPanelFlag.prefix(5)) + "cSta" + app_receiveEngineStr.replacingOccurrences(of: "dismiss", with: "us")) {
                //: needAlert = true
                needAlert = true
                //: message = "Please allow '\(AppName)' to access your microphone in your iPhone's 'Settings-Privacy-Microphone' option"
                message = (String(modelActiveAgentDict.suffix(4)) + "se al" + String(notiSDict.prefix(4)) + String(k_neverLevelValue)) + "\(noti_areaName)" + String(bytes: factoryMessageStatus.map{cutReduceName(hour: $0)}, encoding: .utf8)!
            }

            //: if needAlert {
            if needAlert {
                //: let alertController = UIAlertController(title: nil, message: message, preferredStyle: .alert)
                let alertController = UIAlertController(title: nil, message: message, preferredStyle: .alert)

                //: let action1 = UIAlertAction(title: "Cancel", style: .default) { _ in
                let action1 = UIAlertAction(title: (String(appSumryPath) + String(engineMainString)), style: .default) { _ in
                }
                //: let action2 = UIAlertAction(title: "Go", style: .destructive) { _ in
                let action2 = UIAlertAction(title: "Go", style: .destructive) { _ in
                    //: if let url = URL(string: UIApplication.openSettingsURLString) {
                    if let url = URL(string: UIApplication.openSettingsURLString) {
                        //: UIApplication.shared.open(url, options: [:], completionHandler: { _ in })
                        UIApplication.shared.open(url, options: [:], completionHandler: { _ in })
                    }
                }
                //: alertController.addAction(action1)
                alertController.addAction(action1)
                //: alertController.addAction(action2)
                alertController.addAction(action2)
                //: present(alertController, animated: true)
                present(alertController, animated: true)
            }
        }
    }
}

//: extension AppWebViewController: WKNavigationDelegate, WKUIDelegate {
extension PartyViewController: WKNavigationDelegate, WKUIDelegate {
    //: func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        //: decisionHandler(.allow)
        decisionHandler(.allow)
    }

    //: func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
    func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) {
        //: UIApplication.shared.isNetworkActivityIndicatorVisible = true
        UIApplication.shared.isNetworkActivityIndicatorVisible = true
    }

    //: func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        //: clearJSBgColor()
        inputPrompt()
        //: UIApplication.shared.isNetworkActivityIndicatorVisible = false
        UIApplication.shared.isNetworkActivityIndicatorVisible = false
    }

    //: func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
    func webView(_ webView: WKWebView, didFailProvisionalNavigation navigation: WKNavigation!, withError error: Error) {
        //: let alertController = UIAlertController(title: nil, message: "Poor network, loading failed", preferredStyle: .alert)
        let alertController = UIAlertController(title: nil, message: (String(showReKey.suffix(6)) + "etwo" + String(engineActivityList.suffix(5)) + "oading" + String(noti_conceptAlbumKey.suffix(4)) + managerPageTempState.replacingOccurrences(of: "cancel", with: "d")), preferredStyle: .alert)
        //: let action = UIAlertAction(title: "Refresh", style: .default) { _ in
        let action = UIAlertAction(title: (String(networkCountlessnessFlag) + scaleTabMessage.replacingOccurrences(of: "makeup", with: "sh")), style: .default) { _ in
            //: self.reloadWebView()
            self.group()
        }
        //: alertController.addAction(action)
        alertController.addAction(action)
        //: present(alertController, animated: true)
        present(alertController, animated: true)
        //: UIApplication.shared.isNetworkActivityIndicatorVisible = false
        UIApplication.shared.isNetworkActivityIndicatorVisible = false
    }

    //: func reloadWebView() {
    func group() {
        //: if self.webView.url != nil {
        if self.webView.url != nil {
            //: self.webView.reload()
            self.webView.reload()
        //: } else {
        } else {
            //: self.beginStartRequest()
            self.fail()
        }
    }

    //: func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {}
    func webView(_ webView: WKWebView, didFail navigation: WKNavigation!, withError error: Error) {}

    //: func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
    func webView(_ webView: WKWebView, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        //: DispatchQueue.global().async {
        DispatchQueue.global().async {
            //: if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
            if challenge.protectionSpace.authenticationMethod == NSURLAuthenticationMethodServerTrust {
                //: if challenge.previousFailureCount == 0 {
                if challenge.previousFailureCount == 0 {
                    //: let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!)
                    let credential = URLCredential(trust: challenge.protectionSpace.serverTrust!)
                    //: completionHandler(.useCredential, credential)
                    completionHandler(.useCredential, credential)
                //: } else {
                } else {
                    //: completionHandler(.cancelAuthenticationChallenge, nil)
                    completionHandler(.cancelAuthenticationChallenge, nil)
                }
            //: } else {
            } else {
                //: completionHandler(.cancelAuthenticationChallenge, nil)
                completionHandler(.cancelAuthenticationChallenge, nil)
            }
        }
    }

    //: func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
    func webViewWebContentProcessDidTerminate(_ webView: WKWebView) {
        //: self.reloadWebView()
        self.group()
    }

    //: func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
    func webView(_ webView: WKWebView, runJavaScriptAlertPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping () -> Void) {
        //: pendingAlertCompletion = completionHandler
        pendingAlertCompletion = completionHandler
        //: let alertController = UIAlertController(title: "Alert", message: message, preferredStyle: .alert)
        let alertController = UIAlertController(title: (String(const_policyMode.suffix(5))), message: message, preferredStyle: .alert)
        //: let action = UIAlertAction(title: "OK", style: .default) { _ in
        let action = UIAlertAction(title: "OK", style: .default) { _ in
            //: self.pendingAlertCompletion?()
            self.pendingAlertCompletion?()
            //: self.pendingAlertCompletion = nil
            self.pendingAlertCompletion = nil
        }
        //: alertController.addAction(action)
        alertController.addAction(action)
        //: if let topVC = AppConfig.currentViewController() {
        if let topVC = IndicatorDisableBegin.laissezPasser() {
            //: topVC.present(alertController, animated: true)
            topVC.present(alertController, animated: true)
        //: } else {
        } else {
            // Fallback to avoid crash if cannot present
            //: self.pendingAlertCompletion?()
            self.pendingAlertCompletion?()
            //: self.pendingAlertCompletion = nil
            self.pendingAlertCompletion = nil
        }
    }

    //: func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
    func webView(_ webView: WKWebView, runJavaScriptConfirmPanelWithMessage message: String, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (Bool) -> Void) {
        //: pendingConfirmCompletion = completionHandler
        pendingConfirmCompletion = completionHandler
        //: let alertController = UIAlertController(title: "Alert", message: message, preferredStyle: .alert)
        let alertController = UIAlertController(title: (String(const_policyMode.suffix(5))), message: message, preferredStyle: .alert)
        //: let okAction = UIAlertAction(title: "OK", style: .default) { _ in
        let okAction = UIAlertAction(title: "OK", style: .default) { _ in
            //: self.pendingConfirmCompletion?(true)
            self.pendingConfirmCompletion?(true)
            //: self.pendingConfirmCompletion = nil
            self.pendingConfirmCompletion = nil
        }
        //: let cancelAction = UIAlertAction(title: "Cancel", style: .cancel) { _ in
        let cancelAction = UIAlertAction(title: (String(appSumryPath) + String(engineMainString)), style: .cancel) { _ in
            //: self.pendingConfirmCompletion?(false)
            self.pendingConfirmCompletion?(false)
            //: self.pendingConfirmCompletion = nil
            self.pendingConfirmCompletion = nil
        }
        //: alertController.addAction(cancelAction)
        alertController.addAction(cancelAction)
        //: alertController.addAction(okAction)
        alertController.addAction(okAction)
        //: if let topVC = AppConfig.currentViewController() {
        if let topVC = IndicatorDisableBegin.laissezPasser() {
            //: topVC.present(alertController, animated: true)
            topVC.present(alertController, animated: true)
        //: } else {
        } else {
            // Fallback default = false
            //: self.pendingConfirmCompletion?(false)
            self.pendingConfirmCompletion?(false)
            //: self.pendingConfirmCompletion = nil
            self.pendingConfirmCompletion = nil
        }
    }

    //: func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -> Void) {
    func webView(_ webView: WKWebView, runJavaScriptTextInputPanelWithPrompt prompt: String, defaultText: String?, initiatedByFrame frame: WKFrameInfo, completionHandler: @escaping (String?) -> Void) {
        //: pendingPromptCompletion = completionHandler
        pendingPromptCompletion = completionHandler
        //: let alertController = UIAlertController(title: prompt, message: "", preferredStyle: .alert)
        let alertController = UIAlertController(title: prompt, message: "", preferredStyle: .alert)
        //: alertController.addTextField { textField in
        alertController.addTextField { textField in
            //: textField.text = defaultText
            textField.text = defaultText
        }
        //: let doneAction = UIAlertAction(title: "Done", style: .default) { _ in
        let doneAction = UIAlertAction(title: (String(routerKitError.prefix(4))), style: .default) { _ in
            //: let text = alertController.textFields?.first?.text
            let text = alertController.textFields?.first?.text
            //: self.pendingPromptCompletion?(text)
            self.pendingPromptCompletion?(text)
            //: self.pendingPromptCompletion = nil
            self.pendingPromptCompletion = nil
        }
        //: let cancelAction = UIAlertAction(title: "Cancel", style: .cancel) { _ in
        let cancelAction = UIAlertAction(title: (String(appSumryPath) + String(engineMainString)), style: .cancel) { _ in
            //: self.pendingPromptCompletion?(nil)
            self.pendingPromptCompletion?(nil)
            //: self.pendingPromptCompletion = nil
            self.pendingPromptCompletion = nil
        }
        //: alertController.addAction(cancelAction)
        alertController.addAction(cancelAction)
        //: alertController.addAction(doneAction)
        alertController.addAction(doneAction)
        //: if let topVC = AppConfig.currentViewController() {
        if let topVC = IndicatorDisableBegin.laissezPasser() {
            //: topVC.present(alertController, animated: true)
            topVC.present(alertController, animated: true)
        //: } else {
        } else {
            // Fallback default = nil
            //: self.pendingPromptCompletion?(nil)
            self.pendingPromptCompletion?(nil)
            //: self.pendingPromptCompletion = nil
            self.pendingPromptCompletion = nil
        }
    }

    //: @available(iOS 15.0, *)
    @available(iOS 15.0, *)
    //: func webView(_ webView: WKWebView, requestMediaCapturePermissionFor origin: WKSecurityOrigin, initiatedByFrame frame: WKFrameInfo, type: WKMediaCaptureType, decisionHandler: @escaping (WKPermissionDecision) -> Void) {
    func webView(_ webView: WKWebView, requestMediaCapturePermissionFor origin: WKSecurityOrigin, initiatedByFrame frame: WKFrameInfo, type: WKMediaCaptureType, decisionHandler: @escaping (WKPermissionDecision) -> Void) {
        //: decisionHandler(.grant)
        decisionHandler(.grant)
    }
}

//: extension AppWebViewController {
extension PartyViewController {
    /// Ensure any pending JS dialog completion handlers are executed to avoid WKWebView crash
    //: private func finalizePendingJSHandlersIfNeeded() {
    private func appear() {
        //: if let alertCompletion = pendingAlertCompletion {
        if let alertCompletion = pendingAlertCompletion {
            //: alertCompletion()
            alertCompletion()
            //: pendingAlertCompletion = nil
            pendingAlertCompletion = nil
        }
        //: if let confirmCompletion = pendingConfirmCompletion {
        if let confirmCompletion = pendingConfirmCompletion {
            //: confirmCompletion(false)
            confirmCompletion(false)
            //: pendingConfirmCompletion = nil
            pendingConfirmCompletion = nil
        }
        //: if let promptCompletion = pendingPromptCompletion {
        if let promptCompletion = pendingPromptCompletion {
            //: promptCompletion(nil)
            promptCompletion(nil)
            //: pendingPromptCompletion = nil
            pendingPromptCompletion = nil
        }
    }
    
    /// 通知三方H5刷新金币
    //: func third_jsEvent_refreshCoin() {
    func app() {
        //: self.webView.evaluateJavaScript("HttpTool.NativeToJs('recharge')") { data, error in
        self.webView.evaluateJavaScript(String(bytes: data_previousSoundLargeMsg.map{generateListBehavior(white: $0)}, encoding: .utf8)!) { data, error in
        }
    }
    
    /// js事件：网页展示
    //: @objc private func jsEvent_onPageShow() {
    @objc private func anyRating() {
        //: self.bridge?.callHandler("onPageShow")
        self.bridge?.callHandler((String(const_photoDict.suffix(3)) + String(main_kitSpaceValue)))
        //: self.webView.evaluateJavaScript("window.onPageShow&&onPageShow();") { data, error in
        self.webView.evaluateJavaScript(String(bytes: networkPermissionPath.map{fitLaunch(flexible: $0)}, encoding: .utf8)!) { data, error in
            //: print("jsEvent(onPageShow): \(String(describing: data))---\(String(describing: error))")
        }
    }
    
    /// js事件：网页消失
    //: private func jsEvent_onPageHide() {
    private func post() {
        //: self.bridge?.callHandler("onPageHide")
        self.bridge?.callHandler((String(constQuestionMode.prefix(4)) + "geHid" + modelServerStatus.replacingOccurrences(of: "need", with: "e")))
        //: self.webView.evaluateJavaScript("window.onPageHide&&onPageHide();") { data, error in
        self.webView.evaluateJavaScript(String(bytes: dataSwapFormat.map{postValid(product: $0)}, encoding: .utf8)!) { data, error in
            //: print("jsEvent(onPageHide): \(String(describing: data))---\(String(describing: error))")
        }
    }
}